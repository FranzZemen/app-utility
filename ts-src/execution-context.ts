import Validator, {ValidationError} from 'fastest-validator';
import {AppConfigI, appConfigSchema} from './app-config.js'


export interface ExecutionContextI {
  appContext?: string; // The application context, for example, butchersrow
  thread?: string; // The thread of execution, which can span across processes (if supplied in headers).
  requestId?: string; // The current process request id, as formed from  the aws request id.
  authorization?: string; // Optional authorization in Bearer Token format Bearer [jwt]
  localContext?: string; // Optional local context - user beware of tracking this!
  /*
   If software does not support async, this execution option indicates that an error should be thrown rather than returning
   a promise.  It should be done at the lowest point possible in the stack, for example in this package in this package
   it would be within load-from-module, freeing any code stacks leveraging it from worrying about the option.  It does,
   however, require the context to be set somewhere.

   Examples of async generated by this package:
   - Dynamic import of ES modules
   - Invoking a factory function that returns a promise
   */
  throwOnAsync?: boolean;
  config?: AppConfigI;
}


export const executionContextSchema = {
  type: 'object',
  optional: true,
  props: {
    appContext: {
      type: 'string',
      optional: true
    },
    thread: {
      type: 'string',
      optional: true
    },
    requestId: {
      type: 'string',
      optional: true
    },
    authorization: {
      type: 'string',
      optional: true
    },
    config: appConfigSchema
  }
}

const check = (new Validator()).compile({ec: executionContextSchema});

export function validateExecutionContext(execContext: ExecutionContextI): ValidationError[] | true | Promise<true | ValidationError[]> {
  return check(execContext);
}
